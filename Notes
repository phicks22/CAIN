Table of Contents:

Introduction/Objective:

Coding Process:

    Ant_Lymph

        210130
        The Antigen class organizes the properties and functionalities of a chosen antigen from the Immune Epitope
        Database (IEDB). The Lymphocyte class has similar qualities, but the paratope is a randomly generated aa
        sequence of the same length as the epitope.Experimental properties include epitope, pop, and n for both the
        Antigen and Epitope classes. Each variable will be parameterized while the others remain constant to identify
        patterns and significance of the variableâ€™s dominance over the system.

        210913
        I realized that I needed a dictionary of populations to pass to Bcell_Selction.py instead of a single instance
        of an object so I created a dictionary of N populations as specified in the arguments (terminal commands) to
        be passed onto B-cell selection.

    Main

        210130
        The Main class is an environment where all classes interact and perform their functionalities with one another.
        The function 'binding' simulates the initial binding of the antigen and lymphocyte where the probability of
        binding is calculated by the percent match of the amino acid binding sites.

        210203
        The function utilizes a for loop to iterate through each index of the string "a" and match it to the same index
        of string "l". Each time both indices match, the "count" increases by 1. By dividing "count" by the length of
        "a", the percent match is calculated and is stored as "pr_bind".A while loop is then utilized to run a randomly
        chosen number from 0-1 and if that number is less than or equal to the probability of not binding, the counter
        "bind_time" increases by 1 and the boolean "bound" = FALSE. Once the random number is greater than than the
        probability of not binding, the "self.iteration_counts" dictionary is appended with the key "init_bind" and the
        value "bind_time". Print statements were used to test the accuracy of each component of the function.

        210323
        Once I transferred the code into the PyCharm environment, I noticed that the binding function would continually
        run for too long. I realized that if there was a 0% binding chance, the loop would continuously run (but not in
        Jupyter Lab which was strange). I added a print statement as a return telling the user that there is no chance
        of the sequences to bind.

        210327
        I identified that the lymph1.paratope property is not functioning properly in the Main class binding function.
        The paratope property transfers to the Main file correctly, confirmed by a print statement, however it does not
        get recognized by the binding function even though ant1.epitope functions correctly. To fix this, I called
        instances of the Antigen and Lymphocyte classes in the Main file and both properties epitope and paratope ran
        properly, confirmed by print statements. The next issue I encountered was the infinite while loop if there was
        no probability of binding between the two strings. To rectify this I added a break statement directly after the
        beginning of the while loop so that if count == 0, the loop will not run and the Init_binding_time = 0.


    Bcell_Selection

        210411
        I made the choice to set the default exchange factor at 10, but this will be manipulated in the future. Another
        assumption that is made that each individual in the initial lyphocyte population will begin with exact copies
        of the paratope. Populations will be represented by a single individual for simplicity. Since each population is
        being compared and not individuals, the individuals themselves do not need to be represented. The number of
        individuals in each Antigen/Lymphocyte population will be user set and will be used in the Immune_Response
        functions.

        210912
        I implemented the usage of the PAM-250 matrix by using a Pandas dataframe. The matrix was imported as a txt file
        located in the Resources directory. Columns and row names of the dataframe correspond to each respective
        amino acid.

        210921
        Had to go back and rewrite a good chunk of the clonal selection function because the substitution likelihoods
        were not accurate for each paratope. The substitution likelihoods from the final population were copying
        themselves into the other populations' paratopes. This was recified by creating a self.likelihood dictionary
        where the likelihoods are only identified once. Since the likelihoods are always the same for each amino acid,
        this is plausable. I also decided to substitute with the second maximum value likelihood because the maximum
        value for an amino acid is always itself.

        210925
        Today I picked up from where I left last time. I had most of the clonal selection algorithm completed except for
        the final product where maximum likelihoods are calculated and then amino acids are substituted out for another.
        I completed this and am going to implement a break in the loop where if maximum affinity is reached, selection
        will cease.

    Arg_Parser

        210912
        I created a new file for argument parsing to set the parameters for the antigen and lymphocyte properties such as
        population number, population size, antigen division rate, and antigen epitope. This will allow for a seamless
        user experience when running the scripts. The argparser package was used for this implementation. I ran into an
        issue where the Ant_lymph.py file would not call properties from Arg_Parser.py since it was outside of the Model
        package directory. To resolve this I moved Ant_Lymph.py outside of the directory and will most likely do the
        same with the others.

Testing:

    Ant_Lymph

        210331
        Print statements were initially used to check that the lengths of the epitope and the paratope were equal. Today
        I created a function that tests that instead of me counting each index. This utilizes the unittest package
        and the self.assertEqual function. If the lengths of both properties are not equal then it will return the
        message "len(a) != len(l)." Initially I noticed that if the test passed, there was no notification of passing
        so I added a print statement to affirm that the test passed. In the near future I will make a test.py folder
        and import all relevant data from the other files.

    Main

